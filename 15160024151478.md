# leetcode - tree 笔记

>tips：
>关于树的一些题目中，经常要用到的遍历方法或借助遍历来实现的算法： 广度，递归，前序，中序 ， morris方式
> 对于树的一些题目：递归的使用，很有技巧
> 


## 二叉树构建

### 前序 + 中序 / 中序 + 后序

```
        1           
     2     3        
   4   5      6     
                    
  前序：1 2 4 5 3 6    
  中序：4 2 5 1 3 6    
  后序：4 5 2 6 3 1    

```

二叉树的构建：使用前序序列 + 中序序列 构建一颗二叉树，思想：

1、前序序列的第一个元素是根节点；构建此根节点root；
2、在中序序列中，查找根节点的位置；可以把中序序列分成左，右子树子序列两部分；
   同时，按照左子树元素的个数，把前序序列分成左，右子树的子前序序列；
   
3、使用的递归的方式，使用左右子树对应的前中序列，构建根节点root->left,root->right的左右子树；



### 代码实现：

leetcode连接：

`https://github.com/ww5365/leetcode/blob/master/src/15_binary_tree_build.cpp`






## 二叉树遍历


下面各种遍历的代码实现：
`https://github.com/ww5365/leetcode/blob/master/src/15_binary_tree_build.cpp`


###前序遍历：preorder traversal

```
        1           
     2     3        
   4   5      6     
                    
  前序：1 2 4 5 3 6        

```

实现思想： 非递归 ， 栈的方式  时间复杂度：o(n) 空间：o(n)

1、从根节点开始，访问节点；之后入栈；如果左子树不为空，继续访问，同理之后节点入栈；

2、当左子树为空，出栈节点；获取出栈节点的右子树。非空，继续访问入栈；否则，继续出栈；

3、当栈空&访问节点为空，访问结束；


参考的实现思想：

1、从根节点开始，入栈；
2、栈为非空的情况下，出栈，访问；
3、如果右子树不为空，入栈；如果左子树不为空，入栈；




实现代码：


### 中序遍历：inorder traverse

**开开眼界啊**

morris 方法遍历二叉树 ：时间：o(n) 空间:o(1)

优点：降低了空间复杂度，o(1)

思路：

```
1. 如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

   a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

   b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。

3. 重复以上1、2直到当前节点为空。

```

实现: 参考代码：


### 后序遍历： post traverse

实现思想： 非递归 栈方式  时间复杂度：o(n) 空间：o(n)

 1、左子树节点入栈；同时，记录其右子树是否被访问的标识；     
 2、为空时，出栈；如果标识为已访问，直接access此节点；
 3、如果右子树访问标识是未访问，置为访问，此节点再次入栈（二次入栈）；同时，其右子树节点开始入栈；


 
## 普通二叉树应用

### LCA：lowest common ancestor ：最低公共祖先

思路1：T p q

1、使用栈后续遍历T，查找p和q两个节点；
2、遇到p 或 q，栈中元素，是其所有的祖先节点；保存;
3、从保存的两个栈数据中，寻找最lowest的公共节点；

思路2：T p q

1、p，q 分别在当前节点的左，右子树中，当前节点就是公共祖先；
2、如果p，q，都在当前节点左子树中，到左子树中继续1；
3、如果p,q，都在当前节点右子树中，到右子树中继续1；



## 二叉排序树应用

知道二叉排序树，又叫二叉查找树，他的定义：左小右大
        5
    3      7
   1  2  6    9


有些特殊的tips：
1、中序遍历，是有序序列

### Kth Smallest Element in a BST
 
 使用中序遍历，到k个元素
 





